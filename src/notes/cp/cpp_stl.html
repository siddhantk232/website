<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-09-05 Mon 22:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STL (Standard Template Library)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="siddhant" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">STL (Standard Template Library)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdd84c4a">1. Containers</a>
<ul>
<li><a href="#orgcd1d0e5">1.1. Nested Containers</a></li>
<li><a href="#orgb202bfd">1.2. Pairs</a></li>
<li><a href="#orgc1dccee">1.3. Vectors</a></li>
<li><a href="#org2abe7c0">1.4. Maps</a>
<ul>
<li><a href="#org2de8746">1.4.1. Unordered Maps</a></li>
<li><a href="#org936d22b">1.4.2. Multimaps</a></li>
</ul>
</li>
<li><a href="#org49ded37">1.5. Sets</a></li>
<li><a href="#org0439bda">1.6. Stack</a>
<ul>
<li><a href="#org20f9dda">1.6.1. Operations:</a></li>
<li><a href="#orge3f4870">1.6.2. LC question (valid parens)</a></li>
</ul>
</li>
<li><a href="#org11db65d">1.7. Queues</a>
<ul>
<li><a href="#org13b3f25">1.7.1. Operations:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org769d94d">2. Iterators</a></li>
<li><a href="#orgc2ffef7">3. Algorithms</a>
<ul>
<li>
<ul>
<li><a href="#orgd470614">3.0.1. Sort (O(nlog(n)))</a></li>
<li><a href="#orga979ca9">3.0.2. Lower/Upper Bound (O(log(n)))</a></li>
<li><a href="#org446c8a6">3.0.3. min<sub>element</sub>, max<sub>element</sub>, accumulate, count, find and, reverse</a></li>
<li><a href="#org7a2bbcf">3.0.4. cpp lambdas</a></li>
<li><a href="#orgea41a49">3.0.5. <code>all_of</code>, <code>any_of</code> and, <code>none_of</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org75a6abb">4. Functors</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdd84c4a" class="outline-2">
<h2 id="orgdd84c4a"><span class="section-number-2">1</span> Containers</h2>
<div class="outline-text-2" id="text-1">
<p>
Containers are data structures that are already implemented in STL.
</p>

<p>
Container is further divided into the following data structure types:
</p>

<ul class="org-ul">
<li>Sequential
<ul class="org-ul">
<li>vectors</li>
<li>stack</li>
<li>queue</li>
</ul></li>
<li>Ordered
<ul class="org-ul">
<li>maps</li>
<li>multimap</li>
<li>set</li>
<li>multiset</li>
</ul></li>
<li>Unordered
<ul class="org-ul">
<li>unordered map</li>
<li>unordered set</li>
</ul></li>
</ul>

<p>
Above list does <b>not</b> include all the containers but most relevant ones. See
<a href="https://cplusplus.com/reference/stl/">https://cplusplus.com/reference/stl/</a> for more information on STL containers.
</p>
</div>

<div id="outline-container-orgcd1d0e5" class="outline-3">
<h3 id="orgcd1d0e5"><span class="section-number-3">1.1</span> Nested Containers</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Cotainers can be nested. Some examples are given below.
</p>

<ul class="org-ul">
<li><code>vector&lt;vector&lt;int&gt;&gt;</code></li>
<li><code>map&lt;int, vector&lt;int&gt;&gt;</code></li>
<li><code>set&lt;pair&lt;int, string&gt;&gt;</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgb202bfd" class="outline-3">
<h3 id="orgb202bfd"><span class="section-number-3">1.2</span> Pairs</h3>
<div class="outline-text-3" id="text-1-2">
<p>
pair is defined in the <code>utility</code> header file. Pairs are copied when passed as
arguments or assigned to some other variable. Use cpp references or pointers to
refer to a pair if needed.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main() {
    std::pair&lt;int, std::string&gt; p = {1, "string"};
    std::cout &lt;&lt; p.first &lt;&lt; ":" &lt;&lt; p.second &lt;&lt; std::endl;

    // pairs are copied
    std::pair&lt;int,std::string&gt; p1 = p;
    p1.first = 43;
    std::cout &lt;&lt; p.first &lt;&lt; ":" &lt;&lt; p.second &lt;&lt; std::endl;

    // cpp references use with pairs
    std::pair&lt;int,std::string&gt; &amp;p2 = p;
    p2.first = 69;
    std::cout &lt;&lt; p.first &lt;&lt; ":" &lt;&lt; p.second &lt;&lt; std::endl;

    // with pointers
    std::pair &lt;int, std::string&gt; *p3 = &amp;p;
    p3-&gt;first = 990;
    std::cout &lt;&lt; p.first &lt;&lt; ":" &lt;&lt; p.second &lt;&lt; std::endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc1dccee" class="outline-3">
<h3 id="orgc1dccee"><span class="section-number-3">1.3</span> Vectors</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Dynmaically sized contiguous memory blocks. Defined in <code>vector</code> header file.
Vector has same size limits as arrays in cpp. Local vector can't be more than
10<sup>5</sup> in size and global vector can't be more than 10<sup>7</sup> in size. This limit is on
the contiguous memory allocation that's why it's same for both arrays and
vectors.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; v = {1,2,3};
    // vector of initial size 10 with all values set to 3
    // std::vector&lt;int&gt; x(10) will set all 10 values to 0 (data type's zero value)
    std::vector&lt;int&gt; x(10,3);

    for (int i : x) {
	std::cout &lt;&lt; i &lt;&lt; " ";
    }

    std::cout &lt;&lt; std::endl;

    for (int i : v) {
	std::cout &lt;&lt; i &lt;&lt; std::endl;
    }

    v.push_back(69); // O(1)

    std::cout &lt;&lt; v[3] &lt;&lt; std::endl;
    std::cout &lt;&lt; v.size() &lt;&lt; std::endl;

    v.pop_back(); // O(1)
    std::cout &lt;&lt; v.size() &lt;&lt; std::endl;
}

</pre>
</div>

<p>
Vectors can be copied unlike arrays. Use cpp references or pointers to get a
reference to a vector.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; v = {1,2,3};
    std::vector&lt;int&gt; v1 = v;

    v1.push_back(10);

    for (int i : v) {
	std::cout &lt;&lt; i &lt;&lt; " ";
    }

    std::cout &lt;&lt; std::endl;

    std::vector&lt;int&gt; &amp;v2 = v;
    v2[0] = 99;
    std::cout &lt;&lt; v[0] &lt;&lt; std::endl;

    std::vector&lt;int&gt; *v3 = &amp;v;
    (*v3)[0] = 32;
    std::cout &lt;&lt; v[0] &lt;&lt; std::endl;
}
</pre>
</div>

<p>
Vectors can be nested to created multi-dimensional vectors (2d, 3d, &#x2026;). Vector of pairs is also common in use.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;std::pair&lt;int, int&gt;&gt; v = {{1,2}, {2,9}};

    for (std::pair&lt;int, int&gt; p : v) {
	std::cout &lt;&lt; p.first &lt;&lt; " : " &lt;&lt; p.second &lt;&lt; std::endl;
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org2abe7c0" class="outline-3">
<h3 id="org2abe7c0"><span class="section-number-3">1.4</span> Maps</h3>
<div class="outline-text-3" id="text-1-4">
<p>
A data structure to store collection of <code>key:value</code> pairs. Pairs are stored in
sorted order in a normal Map, use unordered map for storing unordered pairs.
</p>

<p>
<b>Insertion</b> and <b>access</b> in map is O(log(n)). Keys in a map are unique. It'll
replace the old value in case of an overwrite operation.
</p>

<p>
Find operation (O(log(n))) returns an iterator that points to the found pair or
the <code>.end()</code> if the pair does not exist.
</p>

<p>
Erase (<code>map.erase()</code>) (O(log(n))), takes in either the key or the iterator to
the pair we want to erase from the map. You can't pass <code>m.end()</code> to erase as
it's points to the element which is after the last element.
</p>

<p>
Use <code>map.clear()</code> to clear the map.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;

int main() {
    std::map&lt;int, std::string&gt; m;
    m[1] = "abc";
    m.insert({2, "dewf"});
    m[9] = "jsf";
    m[5] = "jsklfjlks";
    m[99]; // insertion will still happen even if we didn't assign anything

    for (auto i : m) {
	std::cout &lt;&lt;  i.first &lt;&lt; " : " &lt;&lt; i.second &lt;&lt; std::endl;
    }

    auto el = m.find(5);

    if (el != m.end()) {
	std::cout &lt;&lt; el-&gt;second &lt;&lt; std::endl;
    }

    m.erase(m.find(1)); // O(log(n)) + O(log(n)) for find and then erase
    m.erase(9); // O(log(n))

    for (auto i : m) {
	std::cout &lt;&lt;  i.first &lt;&lt; " : " &lt;&lt; i.second &lt;&lt; std::endl;
    }
}
</pre>
</div>
</div>

<div id="outline-container-org2de8746" class="outline-4">
<h4 id="org2de8746"><span class="section-number-4">1.4.1</span> Unordered Maps</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Difference from normal normal maps:
</p>

<ul class="org-ul">
<li><b>Inbuilt implementation</b>: uses hash tables. Each key's hash values is
calculated for comparison</li>

<li><b>time complexity</b>: Insertion/Access time is O(1) (average time complexity).
<code>.erase()</code> happens in O(1) when given an iterator.</li>

<li><b>valid key data types</b>: <code>vector&lt;int&gt;</code> or <code>pair&lt;int, int&gt;</code> can't be used as key
of a pair in unordered<sub>maps</sub> as their hash is not predefined by default. All
standard data types (including std::string) can be used.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">#include&lt;iostream&gt;
#include&lt;unordered_map&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; m;
    m[1] = "abc";
    m.insert({2, "dewf"});
    m[9] = "jsf";
    m[5] = "jsklfjlks";
    m[99]; // insertion will still happen even if we didn't assign anything

    for (auto i : m) {
	std::cout &lt;&lt;  i.first &lt;&lt; " : " &lt;&lt; i.second &lt;&lt; std::endl;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org936d22b" class="outline-4">
<h4 id="org936d22b"><span class="section-number-4">1.4.2</span> Multimaps</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Pairs with same keys can exist in a <code>multimap</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org49ded37" class="outline-3">
<h3 id="org49ded37"><span class="section-number-3">1.5</span> Sets</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Collection of unique elements.
</p>

<ul class="org-ul">
<li><b>Normal Sets</b>: Stores elements in sorted order. <b>Insertion/Access</b> takes
<b>O(log(n))</b> time. <b>Find</b> is also <b>O(log(n))</b>. <code>=set.erase()=</code> is same as it was in
maps.</li>

<li><b>Unordered Sets</b>: Stores elements in random order. <b>Insert</b> take <b>O(1)</b> time.
Standard data types (including) strings can be used by default (uses hash for
uniq check).</li>

<li><b>Multisets</b>: allows for duplicate elements. If passed a value to
<code>set.erase()</code>, it'll delete all the occurence of it. With an iterator, it'll
only delete the element that's pointed by the iterator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
    set&lt;string&gt; s = {"gh", "asdf"};
    s.insert("abc");
    s.insert("abc"); // stores unique element

    auto res = s.find("asdf"); // return s.end() if not found
    cout &lt;&lt; *res &lt;&lt; endl;

    for (auto val : s) {
	cout &lt;&lt; val &lt;&lt; endl;
    }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

using namespace std;

int main() {
    unordered_set&lt;string&gt; s = {"sidd"};
    s.insert("sidd"); // stores unique element

    cout &lt;&lt; s.size() &lt;&lt; endl;

    for (auto &amp;val : s) {
	cout &lt;&lt; val &lt;&lt; endl;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0439bda" class="outline-3">
<h3 id="org0439bda"><span class="section-number-3">1.6</span> Stack</h3>
<div class="outline-text-3" id="text-1-6">
<p>
LIFO
</p>
</div>

<div id="outline-container-org20f9dda" class="outline-4">
<h4 id="org20f9dda"><span class="section-number-4">1.6.1</span> Operations:</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>push (element on top of the stack)</li>
<li>pop (element from top of the stack)</li>
<li>top (get the top element of the stack)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
    stack&lt;int&gt; s;
    s.push(2);
    s.push(9);
    s.push(8);
    s.push(3);
    s.push(99);
    s.push(10);

    while(!s.empty()) {
	cout &lt;&lt; s.top() &lt;&lt; endl;
	s.pop();
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3f4870" class="outline-4">
<h4 id="orge3f4870"><span class="section-number-4">1.6.2</span> LC question (valid parens)</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<a href="https://leetcode.com/problems/valid-parentheses">https://leetcode.com/problems/valid-parentheses</a>
</p>
</div>

<ol class="org-ol">
<li><a id="org7280bb9"></a>Solution 1<br />
<div class="outline-text-5" id="text-1-6-2-1">
<div class="org-src-container">
<pre class="src src-cpp" id="org06c1d19">class Solution1 {
public:
    bool isValid(string s) {
	stack&lt;char&gt; st;
	bool res = true;
	for (char &amp;c : s) {
	    if (c == '(' || c == '[' || c == '{') {
		st.push(c);
	    } else {
		if (st.empty()) {
		    res = false;
		} else {
		    auto top = st.top();
		    st.pop();

		    if (c == ')' &amp;&amp; top != '(') {
			res = false;
		    } else if (c == '}' &amp;&amp; top != '{') {
			res = false;
		    } else if (c == ']' &amp;&amp; top != '[') {
			res = false;
		    }
		}
	    }
	}

	if (!st.empty()) {
	    res = false;
	}

	return res;
    }
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp" id="org66e5dc3">class Solution2 {
public:
    unordered_map&lt;char, int&gt; mp = {{'(', -1}, {'{', -2}, {'[', -3}, {')', 1}, {'}', 2}, {']', 3}};
    bool isValid(string s) {
	stack&lt;char&gt; st;
	for (char &amp;c : s) {
	    if (mp[c] &lt; 0) {
		st.push(c);
	    } else {
		if (st.empty()) {
		    return false;
		}
		auto top = st.top();
		st.pop();
		if (mp[top] + mp[c] != 0) {
		    return false;
		}
	    }
	}

	return st.empty();
    }
};
</pre>
</div>

<p>
Driver Code with both the solutions
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;

using namespace std;

class Solution1 {
public:
    bool isValid(string s) {
	stack&lt;char&gt; st;
	bool res = true;
	for (char &amp;c : s) {
	    if (c == '(' || c == '[' || c == '{') {
		st.push(c);
	    } else {
		if (st.empty()) {
		    res = false;
		} else {
		    auto top = st.top();
		    st.pop();

		    if (c == ')' &amp;&amp; top != '(') {
			res = false;
		    } else if (c == '}' &amp;&amp; top != '{') {
			res = false;
		    } else if (c == ']' &amp;&amp; top != '[') {
			res = false;
		    }
		}
	    }
	}

	if (!st.empty()) {
	    res = false;
	}

	return res;
    }
};

class Solution2 {
public:
    unordered_map&lt;char, int&gt; mp = {{'(', -1}, {'{', -2}, {'[', -3}, {')', 1}, {'}', 2}, {']', 3}};
    bool isValid(string s) {
	stack&lt;char&gt; st;
	for (char &amp;c : s) {
	    if (mp[c] &lt; 0) {
		st.push(c);
	    } else {
		if (st.empty()) {
		    return false;
		}
		auto top = st.top();
		st.pop();
		if (mp[top] + mp[c] != 0) {
		    return false;
		}
	    }
	}

	return st.empty();
    }
};

int main() {
    auto sol1 = new Solution1();
    auto sol2 = new Solution2();

    cout &lt;&lt; sol1-&gt;isValid("((()))") &lt;&lt; endl;
    cout &lt;&lt; sol1-&gt;isValid("({[]})") &lt;&lt; endl;

    cout &lt;&lt; sol1-&gt;isValid("(]") &lt;&lt; endl;
    cout &lt;&lt; sol1-&gt;isValid("[](()") &lt;&lt; endl;

    cout &lt;&lt; sol2-&gt;isValid("((()))") &lt;&lt; endl;
    cout &lt;&lt; sol2-&gt;isValid("({[]})") &lt;&lt; endl;

    cout &lt;&lt; sol2-&gt;isValid("(]") &lt;&lt; endl;
    cout &lt;&lt; sol2-&gt;isValid("[](()") &lt;&lt; endl;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org11db65d" class="outline-3">
<h3 id="org11db65d"><span class="section-number-3">1.7</span> Queues</h3>
<div class="outline-text-3" id="text-1-7">
<p>
FIFO
</p>
</div>
<div id="outline-container-org13b3f25" class="outline-4">
<h4 id="org13b3f25"><span class="section-number-4">1.7.1</span> Operations:</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>push (element to the back of the queue)</li>
<li>pop (remove the first element)</li>
<li>front (get the first element of the queue)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main() {
    queue&lt;string&gt; q;
    q.push("abc");
    q.push("def");
    q.push("ghi");
    q.push("jkl");
    q.push("mno");

    while(!q.empty()) {
	cout &lt;&lt; q.front() &lt;&lt; endl;
	q.pop();
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org769d94d" class="outline-2">
<h2 id="org769d94d"><span class="section-number-2">2</span> Iterators</h2>
<div class="outline-text-2" id="text-2">
<p>
Pointer like structures. <code>.begin()</code> points at the first element of a data
structure. <code>.end()</code> points at the element after the last element.
</p>

<p>
Increment operator (++) works for any iterator but adding 1 (<code>it + 1</code>) only
works for vectors.
(+1) moves to the next memory location which, in case of vectors is the location
of the next element. Maps and other data structure do no store elements in
contiguous memory block so this does not work.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v = {1,2,3,4};
    std::vector&lt;int&gt;::iterator it = v.begin();

    std::cout &lt;&lt; (*it) &lt;&lt; std::endl;
    std::cout &lt;&lt; (*(it + 1)) &lt;&lt; std::endl;

    // i++/++i -&gt; next iterator
    for (auto i = v.begin(); i != v.end(); ++i) {
	std::cout &lt;&lt; (*i) &lt;&lt; std::endl;
    }
}
</pre>
</div>

<p>
C++11 introduced range based loops and the <code>auto</code> keyword that shortens the
syntax required for iterator usage.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v = {1,2,3,4};

    // uses iterators under the hood
    // the value inside identifier `i` is copied
    // use cpp references (int &amp;i) when copying is not desired
    for (int i : v) {
	std::cout &lt;&lt; i &lt;&lt; std::endl;
    }

    std::vector&lt;std::pair&lt;int,int&gt;&gt; p = {{1,2}, {3,4}};

    // pi :: pair&lt;int,int&gt;
    // pari&lt;int,int&gt; -&gt; auto!
    for (auto pi : p) {
	std::cout &lt;&lt; pi.first &lt;&lt; std::endl;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc2ffef7" class="outline-2">
<h2 id="orgc2ffef7"><span class="section-number-2">3</span> Algorithms</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>{next,prev}<sub>permutations</sub></li>
</ul>
</div>

<div id="outline-container-orgd470614" class="outline-4">
<h4 id="orgd470614"><span class="section-number-4">3.0.1</span> Sort (O(nlog(n)))</h4>
<div class="outline-text-4" id="text-3-0-1">
<p>
<code>std::sort</code> takes in the first iterator (pointer to the first element) and
pointer to the next element after the last element.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    int a[5] = {3,34,2,61,3};

    sort(a, a+5);

    for (int i : a) {
	cout &lt;&lt; i &lt;&lt; endl;
    }
}
</pre>
</div>

<p>
Usage with vectors:
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    vector&lt;int&gt; a = {1,99,3,4,10, 8};

    sort(a.begin(), a.end());

    for (int i : a) {
	cout &lt;&lt; i &lt;&lt; endl;
    }
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org6b1526f"></a>Comparator Function in Sort<br />
<div class="outline-text-5" id="text-3-0-1-1">
<p>
The default logic for sort is to rearrange container elements in ascending
order. We can change this behaviour
</p>

<p>
Return <code>false</code> from the comparator function if you want to swap, else return
<code>true</code>. We typically pass a comparison expression that when evaluated to
<code>false</code>, triggers the swap operation.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
    if (a.first != b.first) {
	return a.first &lt; b.first;
    }
    return a.second &gt; b.second;
}

int main() {
    vector&lt;pair&lt;int, int&gt;&gt; a = {{4,3}, {5,5}, {5,3}, {25, 6}, {7, 9}, {8, 5}};

    sort(a.begin(), a.end(), cmp);

    for (auto i : a) {
	cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl;
    }
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orga979ca9" class="outline-4">
<h4 id="orga979ca9"><span class="section-number-4">3.0.2</span> Lower/Upper Bound (O(log(n)))</h4>
<div class="outline-text-4" id="text-3-0-2">
<p>
The input to lower/upper bound should be sorted to get O(log(n)) perf. If the
input isn't sorted, it'll take O(n) time.
</p>

<p>
Use <code>set.lower_bound</code> or <code>set.upper_bound</code> and <code>map.lower_bound</code> or
<code>map.upper_bound</code> to get O(log(n)) with sets and maps.
</p>

<p>
<b>Lower bound</b> returns pointer (or iterator) to the given element or next element
bigger than the given element. If both (given element and any element bigger
than the given element) is not found, it'll return <code>.end()</code>.
</p>

<p>
<code>lower_bound</code> searches for element x in a container such that i &lt;= x, where i is
the search argument passed.
</p>


<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    int a[5] = {3,34,2,61,3};

    sort(a, a+5);

    cout &lt;&lt; *lower_bound(a, a+5, 3) &lt;&lt; endl;
    cout &lt;&lt; *lower_bound(a, a+5, 34) &lt;&lt; endl;
    cout &lt;&lt; *lower_bound(a, a+5, 61) &lt;&lt; endl;

    // neither 69 nor any value greater than 69 exist so we get .end()
    if (lower_bound(a, a+5, 69) == (a+5)) {
	cout &lt;&lt; "yes" &lt;&lt; endl;
    }

    // we get 34 as 5 doesn't exist in `a`` and 34 is the next bigger element
    cout &lt;&lt; *lower_bound(a, a+5, 5) &lt;&lt; endl;
}
</pre>
</div>

<p>
<b>Upper bound</b> returns pointer (or iterator) to the element which is greater than the given element.
</p>

<p>
<code>upper_bound</code> searches for element x in a container such that i &lt; x, where i is
the search argument passed.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    int a[5] = {3,34,2,61,3};

    sort(a, a+5);

    cout &lt;&lt; *upper_bound(a, a+5, 3) &lt;&lt; endl;
    cout &lt;&lt; *upper_bound(a, a+5, 34) &lt;&lt; endl;

    if (upper_bound(a, a+5, 61) == (a+5)) {
	cout &lt;&lt; "no element bigger than " &lt;&lt; 61 &lt;&lt; " found" &lt;&lt; endl;
    }

    // neither 69 nor any value greater than 69 exist so we get .end()
    if (upper_bound(a, a+5, 69) == (a+5)) {
	cout &lt;&lt; "no eleme bigger than 69 found" &lt;&lt; endl;
    }

    // we get 34 as 5 doesn't exist in `a`` and 34 is the next bigger element
    cout &lt;&lt; *upper_bound(a, a+5, 5) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>



<div id="outline-container-org446c8a6" class="outline-4">
<h4 id="org446c8a6"><span class="section-number-4">3.0.3</span> min<sub>element</sub>, max<sub>element</sub>, accumulate, count, find and, reverse</h4>
<div class="outline-text-4" id="text-3-0-3">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

using namespace std;

int main() {
    vector&lt;int&gt; v = {1,3,932,342,4,1};

    cout &lt;&lt; *min_element(v.begin(), v.end()) &lt;&lt; endl;
    cout &lt;&lt; *max_element(v.begin(), v.end()) &lt;&lt; endl;

    // accumulate gives sum of all elements in a container
    // defined in the `numeric` header file
    cout &lt;&lt; accumulate(v.begin(), v.end(), 0) &lt;&lt; endl;

    // count returns the number of occurrence of some element in a container
    cout &lt;&lt; count(v.begin(), v.end(), 1) &lt;&lt; endl;

    // find
    auto it = find(v.begin(), v.end(), 69);
    if (it != v.end()) cout &lt;&lt; *it &lt;&lt; endl;
    else cout &lt;&lt; "not found" &lt;&lt; endl;

    // reverse
    reverse(v.begin(), v.end());

    for (int &amp;i:v) {
	cout &lt;&lt; i &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    string s = "abcdef";
    reverse(s.begin(), s.end());
    cout &lt;&lt; s &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7a2bbcf" class="outline-4">
<h4 id="org7a2bbcf"><span class="section-number-4">3.0.4</span> cpp lambdas</h4>
<div class="outline-text-4" id="text-3-0-4">
<p>
Lambdas in cpp can be used to create functions that are created for one time
use. Lambda funcs can be assigned too.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    vector&lt;int&gt; v = {1,3,932,342,4,1};

    for (int i : v) {
	cout &lt;&lt; i &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    // sort in descending order using cpp lambdas
    sort(v.begin(), v.end(), [](int a, int b){ return a &gt; b; });

    for (int i : v) {
	cout &lt;&lt; i &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; [](int x){ return x*2; }(10) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea41a49" class="outline-4">
<h4 id="orgea41a49"><span class="section-number-4">3.0.5</span> <code>all_of</code>, <code>any_of</code> and, <code>none_of</code></h4>
<div class="outline-text-4" id="text-3-0-5">
<p>
<b><code>all_of</code></b>: returns true if the provided function returns true for all the
 elements.
<b><code>any_of</code></b>: returns true if the provided function returns true for at least one
 element.
<b><code>none_of</code></b>: returns true if the provided function returns false for all the
 elements.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    vector&lt;int&gt; v = {1,3,932,342,4,1};

    // checks if all the elements are greater than 10 (they're not)
    cout &lt;&lt; all_of(v.begin(), v.end(), [](auto a) { return a &gt; 10; }) &lt;&lt; endl;
    cout &lt;&lt; any_of(v.begin(), v.end(), [](auto a) { return a &gt; 10; }) &lt;&lt; endl;
    // since none of the elments are negative, it prints 1 (true)
    cout &lt;&lt; none_of(v.begin(), v.end(), [](auto a) { return a &lt; 0; }) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org75a6abb" class="outline-2">
<h2 id="org75a6abb"><span class="section-number-2">4</span> Functors</h2>
<div class="outline-text-2" id="text-4">
<p>
TODO look more into this topic (not important for LC)
Classes that act as functions?
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: siddhant</p>
<p class="date">Created: 2022-09-05 Mon 22:31</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
