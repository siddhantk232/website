<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-28 Wed 11:20 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STL (Standard Template Library)</title>
<meta name="author" content="siddhant" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">STL (Standard Template Library)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgcaf5fb9">1. Containers</a>
<ul>
<li><a href="#orge928503">1.1. Nested Containers</a></li>
<li><a href="#org8857a69">1.2. Pairs</a></li>
<li><a href="#org0d4ea33">1.3. Vectors</a></li>
<li><a href="#orgd687783">1.4. Maps</a>
<ul>
<li><a href="#orgac2182b">1.4.1. Unordered Maps</a></li>
<li><a href="#orgc58b600">1.4.2. Multimaps</a></li>
</ul>
</li>
<li><a href="#org10d5367">1.5. Sets</a></li>
<li><a href="#org7240e31">1.6. Stack</a>
<ul>
<li><a href="#orge266fad">1.6.1. Operations:</a></li>
<li><a href="#org045f364">1.6.2. LC question (valid parens)</a></li>
</ul>
</li>
<li><a href="#org0c18410">1.7. Queues</a>
<ul>
<li><a href="#org21cb74a">1.7.1. Operations:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8381ed5">2. Iterators</a></li>
<li><a href="#org8e58474">3. Algorithms</a>
<ul>
<li>
<ul>
<li><a href="#org15c509c">3.0.1. Sort (O(nlog(n)))</a></li>
<li><a href="#orgb478b00">3.0.2. Lower/Upper Bound (O(log(n)))</a></li>
<li><a href="#org87fccfe">3.0.3. min<sub>element</sub>, max<sub>element</sub>, accumulate, count, find and, reverse</a></li>
<li><a href="#org296876d">3.0.4. cpp lambdas</a></li>
<li><a href="#orge03fc5f">3.0.5. <code>all_of</code>, <code>any_of</code> and, <code>none_of</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6a8fc58">4. Functors</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcaf5fb9" class="outline-2">
<h2 id="orgcaf5fb9"><span class="section-number-2">1.</span> Containers</h2>
<div class="outline-text-2" id="text-1">
<p>
Containers are data structures that are already implemented in STL.
</p>

<p>
Container is further divided into the following data structure types:
</p>

<ul class="org-ul">
<li>Sequential
<ul class="org-ul">
<li>vectors</li>
<li>stack</li>
<li>queue</li>
</ul></li>
<li>Ordered
<ul class="org-ul">
<li>maps</li>
<li>multimap</li>
<li>set</li>
<li>multiset</li>
</ul></li>
<li>Unordered
<ul class="org-ul">
<li>unordered map</li>
<li>unordered set</li>
</ul></li>
</ul>

<p>
Above list does <b>not</b> include all the containers but most relevant ones. See
<a href="https://cplusplus.com/reference/stl/">https://cplusplus.com/reference/stl/</a> for more information on STL containers.
</p>
</div>

<div id="outline-container-orge928503" class="outline-3">
<h3 id="orge928503"><span class="section-number-3">1.1.</span> Nested Containers</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Cotainers can be nested. Some examples are given below.
</p>

<ul class="org-ul">
<li><code>vector&lt;vector&lt;int&gt;&gt;</code></li>
<li><code>map&lt;int, vector&lt;int&gt;&gt;</code></li>
<li><code>set&lt;pair&lt;int, string&gt;&gt;</code></li>
</ul>
</div>
</div>

<div id="outline-container-org8857a69" class="outline-3">
<h3 id="org8857a69"><span class="section-number-3">1.2.</span> Pairs</h3>
<div class="outline-text-3" id="text-1-2">
<p>
pair is defined in the <code>utility</code> header file. Pairs are copied when passed as
arguments or assigned to some other variable. Use cpp references or pointers to
refer to a pair if needed.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;utility&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-constant">std</span>::string&gt; <span class="org-variable-name">p</span> = {1, <span class="org-string">"string"</span>};
    <span class="org-constant">std</span>::cout &lt;&lt; p.first &lt;&lt; <span class="org-string">":"</span> &lt;&lt; p.second &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">pairs are copied</span>
    <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>,<span class="org-constant">std</span>::string&gt; <span class="org-variable-name">p1</span> = p;
    p1.first = 43;
    <span class="org-constant">std</span>::cout &lt;&lt; p.first &lt;&lt; <span class="org-string">":"</span> &lt;&lt; p.second &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">cpp references use with pairs</span>
    <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>,<span class="org-constant">std</span>::string&gt; &amp;<span class="org-variable-name">p2</span> = p;
    p2.first = 69;
    <span class="org-constant">std</span>::cout &lt;&lt; p.first &lt;&lt; <span class="org-string">":"</span> &lt;&lt; p.second &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">with pointers</span>
    <span class="org-constant">std</span>::<span class="org-type">pair</span> &lt;<span class="org-type">int</span>, <span class="org-constant">std</span>::string&gt; *<span class="org-variable-name">p3</span> = &amp;p;
    p3-&gt;first = 990;
    <span class="org-constant">std</span>::cout &lt;&lt; p.first &lt;&lt; <span class="org-string">":"</span> &lt;&lt; p.second &lt;&lt; <span class="org-constant">std</span>::endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d4ea33" class="outline-3">
<h3 id="org0d4ea33"><span class="section-number-3">1.3.</span> Vectors</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Dynmaically sized contiguous memory blocks. Defined in <code>vector</code> header file.
Vector has same size limits as arrays in cpp. Local vector can't be more than
10<sup>5</sup> in size and global vector can't be more than 10<sup>7</sup> in size. This limit is on
the contiguous memory allocation that's why it's same for both arrays and
vectors.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,2,3};
    <span class="org-comment-delimiter">// </span><span class="org-comment">vector of initial size 10 with all values set to 3</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::vector&lt;int&gt; x(10) will set all 10 values to 0 (data type's zero value)</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">x</span>(10,3);

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : x) {
        <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span>;
    }

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : v) {
        <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-constant">std</span>::endl;
    }

    v.push_back(69); <span class="org-comment-delimiter">// </span><span class="org-comment">O(1)</span>

    <span class="org-constant">std</span>::cout &lt;&lt; v[3] &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; v.size() &lt;&lt; <span class="org-constant">std</span>::endl;

    v.pop_back(); <span class="org-comment-delimiter">// </span><span class="org-comment">O(1)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; v.size() &lt;&lt; <span class="org-constant">std</span>::endl;
}

</pre>
</div>

<p>
Vectors can be copied unlike arrays. Use cpp references or pointers to get a
reference to a vector.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,2,3};
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v1</span> = v;

    v1.push_back(10);

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : v) {
        <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span>;
    }

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; &amp;<span class="org-variable-name">v2</span> = v;
    v2[0] = 99;
    <span class="org-constant">std</span>::cout &lt;&lt; v[0] &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; *<span class="org-variable-name">v3</span> = &amp;v;
    (*v3)[0] = 32;
    <span class="org-constant">std</span>::cout &lt;&lt; v[0] &lt;&lt; <span class="org-constant">std</span>::endl;
}
</pre>
</div>

<p>
Vectors can be nested to created multi-dimensional vectors (2d, 3d, &#x2026;). Vector of pairs is also common in use.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;utility&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt;&gt; <span class="org-variable-name">v</span> = {{1,2}, {2,9}};

    <span class="org-keyword">for</span> (<span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">p</span> : v) {
        <span class="org-constant">std</span>::cout &lt;&lt; p.first &lt;&lt; <span class="org-string">" : "</span> &lt;&lt; p.second &lt;&lt; <span class="org-constant">std</span>::endl;
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd687783" class="outline-3">
<h3 id="orgd687783"><span class="section-number-3">1.4.</span> Maps</h3>
<div class="outline-text-3" id="text-1-4">
<p>
A data structure to store collection of <code>key:value</code> pairs. Pairs are stored in
sorted order in a normal Map, use unordered map for storing unordered pairs.
</p>

<p>
<b>Insertion</b> and <b>access</b> in map is O(log(n)). Keys in a map are unique. It'll
replace the old value in case of an overwrite operation.
</p>

<p>
Find operation (O(log(n))) returns an iterator that points to the found pair or
the <code>.end()</code> if the pair does not exist.
</p>

<p>
Erase (<code>map.erase()</code>) (O(log(n))), takes in either the key or the iterator to
the pair we want to erase from the map. You can't pass <code>m.end()</code> to erase as
it's points to the element which is after the last element.
</p>

<p>
Use <code>map.clear()</code> to clear the map.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span><span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span><span class="org-string">&lt;map&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">map</span>&lt;<span class="org-type">int</span>, <span class="org-constant">std</span>::string&gt; <span class="org-variable-name">m</span>;
    m[1] = <span class="org-string">"abc"</span>;
    m.insert({2, <span class="org-string">"dewf"</span>});
    m[9] = <span class="org-string">"jsf"</span>;
    m[5] = <span class="org-string">"jsklfjlks"</span>;
    m[99]; <span class="org-comment-delimiter">// </span><span class="org-comment">insertion will still happen even if we didn't assign anything</span>

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> : m) {
        <span class="org-constant">std</span>::cout &lt;&lt;  i.first &lt;&lt; <span class="org-string">" : "</span> &lt;&lt; i.second &lt;&lt; <span class="org-constant">std</span>::endl;
    }

    <span class="org-keyword">auto</span> <span class="org-variable-name">el</span> = m.find(5);

    <span class="org-keyword">if</span> (el != m.end()) {
        <span class="org-constant">std</span>::cout &lt;&lt; el-&gt;second &lt;&lt; <span class="org-constant">std</span>::endl;
    }

    m.erase(m.find(1)); <span class="org-comment-delimiter">// </span><span class="org-comment">O(log(n)) + O(log(n)) for find and then erase</span>
    m.erase(9); <span class="org-comment-delimiter">// </span><span class="org-comment">O(log(n))</span>

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> : m) {
        <span class="org-constant">std</span>::cout &lt;&lt;  i.first &lt;&lt; <span class="org-string">" : "</span> &lt;&lt; i.second &lt;&lt; <span class="org-constant">std</span>::endl;
    }
}
</pre>
</div>
</div>

<div id="outline-container-orgac2182b" class="outline-4">
<h4 id="orgac2182b"><span class="section-number-4">1.4.1.</span> Unordered Maps</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Difference from normal normal maps:
</p>

<ul class="org-ul">
<li><b>Inbuilt implementation</b>: uses hash tables. Each key's hash values is
calculated for comparison</li>

<li><b>time complexity</b>: Insertion/Access time is O(1) (average time complexity).
<code>.erase()</code> happens in O(1) when given an iterator.</li>

<li><b>valid key data types</b>: <code>vector&lt;int&gt;</code> or <code>pair&lt;int, int&gt;</code> can't be used as key
of a pair in unordered<sub>maps</sub> as their hash is not predefined by default. All
standard data types (including std::string) can be used.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span><span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span><span class="org-string">&lt;unordered_map&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-constant">std</span>::string&gt; <span class="org-variable-name">m</span>;
    m[1] = <span class="org-string">"abc"</span>;
    m.insert({2, <span class="org-string">"dewf"</span>});
    m[9] = <span class="org-string">"jsf"</span>;
    m[5] = <span class="org-string">"jsklfjlks"</span>;
    m[99]; <span class="org-comment-delimiter">// </span><span class="org-comment">insertion will still happen even if we didn't assign anything</span>

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> : m) {
        <span class="org-constant">std</span>::cout &lt;&lt;  i.first &lt;&lt; <span class="org-string">" : "</span> &lt;&lt; i.second &lt;&lt; <span class="org-constant">std</span>::endl;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc58b600" class="outline-4">
<h4 id="orgc58b600"><span class="section-number-4">1.4.2.</span> Multimaps</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Pairs with same keys can exist in a <code>multimap</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org10d5367" class="outline-3">
<h3 id="org10d5367"><span class="section-number-3">1.5.</span> Sets</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Collection of unique elements.
</p>

<ul class="org-ul">
<li><b>Normal Sets</b>: Stores elements in sorted order. <b>Insertion/Access</b> takes
<b>O(log(n))</b> time. <b>Find</b> is also <b>O(log(n))</b>. <code>=set.erase()=</code> is same as it was in
maps.</li>

<li><b>Unordered Sets</b>: Stores elements in random order. <b>Insert</b> take <b>O(1)</b> time.
Standard data types (including) strings can be used by default (uses hash for
uniq check).</li>

<li><b>Multisets</b>: allows for duplicate elements. If passed a value to
<code>set.erase()</code>, it'll delete all the occurence of it. With an iterator, it'll
only delete the element that's pointed by the iterator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;set&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">set</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">s</span> = {<span class="org-string">"gh"</span>, <span class="org-string">"asdf"</span>};
    s.insert(<span class="org-string">"abc"</span>);
    s.insert(<span class="org-string">"abc"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">stores unique element</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = s.find(<span class="org-string">"asdf"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">return s.end() if not found</span>
    cout &lt;&lt; *res &lt;&lt; endl;

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">val</span> : s) {
        cout &lt;&lt; val &lt;&lt; endl;
    }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unordered_set&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">unordered_set</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">s</span> = {<span class="org-string">"sidd"</span>};
    s.insert(<span class="org-string">"sidd"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">stores unique element</span>

    cout &lt;&lt; s.size() &lt;&lt; endl;

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> &amp;<span class="org-variable-name">val</span> : s) {
        cout &lt;&lt; val &lt;&lt; endl;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7240e31" class="outline-3">
<h3 id="org7240e31"><span class="section-number-3">1.6.</span> Stack</h3>
<div class="outline-text-3" id="text-1-6">
<p>
LIFO
</p>
</div>

<div id="outline-container-orge266fad" class="outline-4">
<h4 id="orge266fad"><span class="section-number-4">1.6.1.</span> Operations:</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>push (element on top of the stack)</li>
<li>pop (element from top of the stack)</li>
<li>top (get the top element of the stack)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">s</span>;
    s.push(2);
    s.push(9);
    s.push(8);
    s.push(3);
    s.push(99);
    s.push(10);

    <span class="org-keyword">while</span>(<span class="org-negation-char">!</span>s.empty()) {
        cout &lt;&lt; s.top() &lt;&lt; endl;
        s.pop();
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org045f364" class="outline-4">
<h4 id="org045f364"><span class="section-number-4">1.6.2.</span> LC question (valid parens)</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<a href="https://leetcode.com/problems/valid-parentheses">https://leetcode.com/problems/valid-parentheses</a>
</p>
</div>

<ol class="org-ol">
<li><a id="orgb0b0d12"></a>Solution 1<br />
<div class="outline-text-5" id="text-1-6-2-1">
<div class="org-src-container">
<pre class="src src-cpp" id="org3a51d56"><span class="org-keyword">class</span> <span class="org-type">Solution1</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isValid</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">stack</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">st</span>;
        <span class="org-type">bool</span> <span class="org-variable-name">res</span> = <span class="org-constant">true</span>;
        <span class="org-keyword">for</span> (<span class="org-type">char</span> &amp;<span class="org-variable-name">c</span> : s) {
            <span class="org-keyword">if</span> (c == <span class="org-string">'('</span> || c == <span class="org-string">'['</span> || c == <span class="org-string">'{'</span>) {
                st.push(c);
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span> (st.empty()) {
                    res = <span class="org-constant">false</span>;
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">auto</span> <span class="org-variable-name">top</span> = st.top();
                    st.pop();

                    <span class="org-keyword">if</span> (c == <span class="org-string">')'</span> &amp;&amp; top != <span class="org-string">'('</span>) {
                        res = <span class="org-constant">false</span>;
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (c == <span class="org-string">'}'</span> &amp;&amp; top != <span class="org-string">'{'</span>) {
                        res = <span class="org-constant">false</span>;
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (c == <span class="org-string">']'</span> &amp;&amp; top != <span class="org-string">'['</span>) {
                        res = <span class="org-constant">false</span>;
                    }
                }
            }
        }

        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>st.empty()) {
            res = <span class="org-constant">false</span>;
        }

        <span class="org-keyword">return</span> res;
    }
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp" id="org9fea47e"><span class="org-keyword">class</span> <span class="org-type">Solution2</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">unordered_map</span>&lt;<span class="org-type">char</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">mp</span> = {{<span class="org-string">'('</span>, -1}, {<span class="org-string">'{'</span>, -2}, {<span class="org-string">'['</span>, -3}, {<span class="org-string">')'</span>, 1}, {<span class="org-string">'}'</span>, 2}, {<span class="org-string">']'</span>, 3}};
    <span class="org-type">bool</span> <span class="org-function-name">isValid</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">stack</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">st</span>;
        <span class="org-keyword">for</span> (<span class="org-type">char</span> &amp;<span class="org-variable-name">c</span> : s) {
            <span class="org-keyword">if</span> (mp[c] &lt; 0) {
                st.push(c);
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span> (st.empty()) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
                <span class="org-keyword">auto</span> <span class="org-variable-name">top</span> = st.top();
                st.pop();
                <span class="org-keyword">if</span> (mp[top] + mp[c] != 0) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
            }
        }

        <span class="org-keyword">return</span> st.empty();
    }
};
</pre>
</div>

<p>
Driver Code with both the solutions
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unordered_map&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">class</span> <span class="org-type">Solution1</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isValid</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">stack</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">st</span>;
        <span class="org-type">bool</span> <span class="org-variable-name">res</span> = <span class="org-constant">true</span>;
        <span class="org-keyword">for</span> (<span class="org-type">char</span> &amp;<span class="org-variable-name">c</span> : s) {
            <span class="org-keyword">if</span> (c == <span class="org-string">'('</span> || c == <span class="org-string">'['</span> || c == <span class="org-string">'{'</span>) {
                st.push(c);
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span> (st.empty()) {
                    res = <span class="org-constant">false</span>;
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">auto</span> <span class="org-variable-name">top</span> = st.top();
                    st.pop();

                    <span class="org-keyword">if</span> (c == <span class="org-string">')'</span> &amp;&amp; top != <span class="org-string">'('</span>) {
                        res = <span class="org-constant">false</span>;
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (c == <span class="org-string">'}'</span> &amp;&amp; top != <span class="org-string">'{'</span>) {
                        res = <span class="org-constant">false</span>;
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (c == <span class="org-string">']'</span> &amp;&amp; top != <span class="org-string">'['</span>) {
                        res = <span class="org-constant">false</span>;
                    }
                }
            }
        }

        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>st.empty()) {
            res = <span class="org-constant">false</span>;
        }

        <span class="org-keyword">return</span> res;
    }
};

<span class="org-keyword">class</span> <span class="org-type">Solution2</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">unordered_map</span>&lt;<span class="org-type">char</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">mp</span> = {{<span class="org-string">'('</span>, -1}, {<span class="org-string">'{'</span>, -2}, {<span class="org-string">'['</span>, -3}, {<span class="org-string">')'</span>, 1}, {<span class="org-string">'}'</span>, 2}, {<span class="org-string">']'</span>, 3}};
    <span class="org-type">bool</span> <span class="org-function-name">isValid</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">stack</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">st</span>;
        <span class="org-keyword">for</span> (<span class="org-type">char</span> &amp;<span class="org-variable-name">c</span> : s) {
            <span class="org-keyword">if</span> (mp[c] &lt; 0) {
                st.push(c);
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span> (st.empty()) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
                <span class="org-keyword">auto</span> <span class="org-variable-name">top</span> = st.top();
                st.pop();
                <span class="org-keyword">if</span> (mp[top] + mp[c] != 0) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
            }
        }

        <span class="org-keyword">return</span> st.empty();
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-keyword">auto</span> <span class="org-variable-name">sol1</span> = <span class="org-keyword">new</span> <span class="org-type">Solution1</span>();
    <span class="org-keyword">auto</span> <span class="org-variable-name">sol2</span> = <span class="org-keyword">new</span> <span class="org-type">Solution2</span>();

    cout &lt;&lt; sol1-&gt;isValid(<span class="org-string">"((()))"</span>) &lt;&lt; endl;
    cout &lt;&lt; sol1-&gt;isValid(<span class="org-string">"({[]})"</span>) &lt;&lt; endl;

    cout &lt;&lt; sol1-&gt;isValid(<span class="org-string">"(]"</span>) &lt;&lt; endl;
    cout &lt;&lt; sol1-&gt;isValid(<span class="org-string">"[](()"</span>) &lt;&lt; endl;

    cout &lt;&lt; sol2-&gt;isValid(<span class="org-string">"((()))"</span>) &lt;&lt; endl;
    cout &lt;&lt; sol2-&gt;isValid(<span class="org-string">"({[]})"</span>) &lt;&lt; endl;

    cout &lt;&lt; sol2-&gt;isValid(<span class="org-string">"(]"</span>) &lt;&lt; endl;
    cout &lt;&lt; sol2-&gt;isValid(<span class="org-string">"[](()"</span>) &lt;&lt; endl;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org0c18410" class="outline-3">
<h3 id="org0c18410"><span class="section-number-3">1.7.</span> Queues</h3>
<div class="outline-text-3" id="text-1-7">
<p>
FIFO
</p>
</div>
<div id="outline-container-org21cb74a" class="outline-4">
<h4 id="org21cb74a"><span class="section-number-4">1.7.1.</span> Operations:</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>push (element to the back of the queue)</li>
<li>pop (remove the first element)</li>
<li>front (get the first element of the queue)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;queue&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">queue</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">q</span>;
    q.push(<span class="org-string">"abc"</span>);
    q.push(<span class="org-string">"def"</span>);
    q.push(<span class="org-string">"ghi"</span>);
    q.push(<span class="org-string">"jkl"</span>);
    q.push(<span class="org-string">"mno"</span>);

    <span class="org-keyword">while</span>(<span class="org-negation-char">!</span>q.empty()) {
        cout &lt;&lt; q.front() &lt;&lt; endl;
        q.pop();
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8381ed5" class="outline-2">
<h2 id="org8381ed5"><span class="section-number-2">2.</span> Iterators</h2>
<div class="outline-text-2" id="text-2">
<p>
Pointer like structures. <code>.begin()</code> points at the first element of a data
structure. <code>.end()</code> points at the element after the last element.
</p>

<p>
Increment operator (++) works for any iterator but adding 1 (<code>it + 1</code>) only
works for vectors.
(+1) moves to the next memory location which, in case of vectors is the location
of the next element. Maps and other data structure do no store elements in
contiguous memory block so this does not work.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,2,3,4};
    <span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">int</span>&gt;::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = v.begin();

    <span class="org-constant">std</span>::cout &lt;&lt; (*it) &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; (*(it + 1)) &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">i++/++i -&gt; next iterator</span>
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> = v.begin(); i != v.end(); ++i) {
        <span class="org-constant">std</span>::cout &lt;&lt; (*i) &lt;&lt; <span class="org-constant">std</span>::endl;
    }
}
</pre>
</div>

<p>
C++11 introduced range based loops and the <code>auto</code> keyword that shortens the
syntax required for iterator usage.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,2,3,4};

    <span class="org-comment-delimiter">// </span><span class="org-comment">uses iterators under the hood</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the value inside identifier `i` is copied</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">use cpp references (int &amp;i) when copying is not desired</span>
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : v) {
        <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-constant">std</span>::endl;
    }

    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>,<span class="org-type">int</span>&gt;&gt; <span class="org-variable-name">p</span> = {{1,2}, {3,4}};

    <span class="org-comment-delimiter">// </span><span class="org-comment">pi :: pair&lt;int,int&gt;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">pari&lt;int,int&gt; -&gt; auto!</span>
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">pi</span> : p) {
        <span class="org-constant">std</span>::cout &lt;&lt; pi.first &lt;&lt; <span class="org-constant">std</span>::endl;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e58474" class="outline-2">
<h2 id="org8e58474"><span class="section-number-2">3.</span> Algorithms</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>{next,prev}<sub>permutations</sub></li>
</ul>
</div>

<div id="outline-container-org15c509c" class="outline-4">
<h4 id="org15c509c"><span class="section-number-4">3.0.1.</span> Sort (O(nlog(n)))</h4>
<div class="outline-text-4" id="text-3-0-1">
<p>
<code>std::sort</code> takes in the first iterator (pointer to the first element) and
pointer to the next element after the last element.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">a</span>[5] = {3,34,2,61,3};

    sort(a, a+5);

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : a) {
        cout &lt;&lt; i &lt;&lt; endl;
    }
}
</pre>
</div>

<p>
Usage with vectors:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">a</span> = {1,99,3,4,10, 8};

    sort(a.begin(), a.end());

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : a) {
        cout &lt;&lt; i &lt;&lt; endl;
    }
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgdcd68a2"></a>Comparator Function in Sort<br />
<div class="outline-text-5" id="text-3-0-1-1">
<p>
The default logic for sort is to rearrange container elements in ascending
order. We can change this behaviour
</p>

<p>
Return <code>false</code> from the comparator function if you want to swap, else return
<code>true</code>. We typically pass a comparison expression that when evaluated to
<code>false</code>, triggers the swap operation.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">bool</span> <span class="org-function-name">cmp</span>(<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">a</span>, <span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">b</span>) {
    <span class="org-keyword">if</span> (a.first != b.first) {
        <span class="org-keyword">return</span> a.first &lt; b.first;
    }
    <span class="org-keyword">return</span> a.second &gt; b.second;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt;&gt; <span class="org-variable-name">a</span> = {{4,3}, {5,5}, {5,3}, {25, 6}, {7, 9}, {8, 5}};

    sort(a.begin(), a.end(), cmp);

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> : a) {
        cout &lt;&lt; i.first &lt;&lt; <span class="org-string">" "</span> &lt;&lt; i.second &lt;&lt; endl;
    }
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb478b00" class="outline-4">
<h4 id="orgb478b00"><span class="section-number-4">3.0.2.</span> Lower/Upper Bound (O(log(n)))</h4>
<div class="outline-text-4" id="text-3-0-2">
<p>
The input to lower/upper bound should be sorted to get O(log(n)) perf. If the
input isn't sorted, it'll take O(n) time.
</p>

<p>
Use <code>set.lower_bound</code> or <code>set.upper_bound</code> and <code>map.lower_bound</code> or
<code>map.upper_bound</code> to get O(log(n)) with sets and maps.
</p>

<p>
<b>Lower bound</b> returns pointer (or iterator) to the given element or next element
bigger than the given element. If both (given element and any element bigger
than the given element) is not found, it'll return <code>.end()</code>.
</p>

<p>
<code>lower_bound</code> searches for element x in a container such that i &lt;= x, where i is
the search argument passed.
</p>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">a</span>[5] = {3,34,2,61,3};

    sort(a, a+5);

    cout &lt;&lt; *lower_bound(a, a+5, 3) &lt;&lt; endl;
    cout &lt;&lt; *lower_bound(a, a+5, 34) &lt;&lt; endl;
    cout &lt;&lt; *lower_bound(a, a+5, 61) &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">neither 69 nor any value greater than 69 exist so we get .end()</span>
    <span class="org-keyword">if</span> (lower_bound(a, a+5, 69) == (a+5)) {
        cout &lt;&lt; <span class="org-string">"yes"</span> &lt;&lt; endl;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">we get 34 as 5 doesn't exist in `a`` and 34 is the next bigger element</span>
    cout &lt;&lt; *lower_bound(a, a+5, 5) &lt;&lt; endl;
}
</pre>
</div>

<p>
<b>Upper bound</b> returns pointer (or iterator) to the element which is greater than the given element.
</p>

<p>
<code>upper_bound</code> searches for element x in a container such that i &lt; x, where i is
the search argument passed.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">a</span>[5] = {3,34,2,61,3};

    sort(a, a+5);

    cout &lt;&lt; *upper_bound(a, a+5, 3) &lt;&lt; endl;
    cout &lt;&lt; *upper_bound(a, a+5, 34) &lt;&lt; endl;

    <span class="org-keyword">if</span> (upper_bound(a, a+5, 61) == (a+5)) {
        cout &lt;&lt; <span class="org-string">"no element bigger than "</span> &lt;&lt; 61 &lt;&lt; <span class="org-string">" found"</span> &lt;&lt; endl;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">neither 69 nor any value greater than 69 exist so we get .end()</span>
    <span class="org-keyword">if</span> (upper_bound(a, a+5, 69) == (a+5)) {
        cout &lt;&lt; <span class="org-string">"no eleme bigger than 69 found"</span> &lt;&lt; endl;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">we get 34 as 5 doesn't exist in `a`` and 34 is the next bigger element</span>
    cout &lt;&lt; *upper_bound(a, a+5, 5) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>



<div id="outline-container-org87fccfe" class="outline-4">
<h4 id="org87fccfe"><span class="section-number-4">3.0.3.</span> min<sub>element</sub>, max<sub>element</sub>, accumulate, count, find and, reverse</h4>
<div class="outline-text-4" id="text-3-0-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;numeric&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,3,932,342,4,1};

    cout &lt;&lt; *min_element(v.begin(), v.end()) &lt;&lt; endl;
    cout &lt;&lt; *max_element(v.begin(), v.end()) &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">accumulate gives sum of all elements in a container</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">defined in the `numeric` header file</span>
    cout &lt;&lt; accumulate(v.begin(), v.end(), 0) &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">count returns the number of occurrence of some element in a container</span>
    cout &lt;&lt; count(v.begin(), v.end(), 1) &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">find</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = find(v.begin(), v.end(), 69);
    <span class="org-keyword">if</span> (it != v.end()) cout &lt;&lt; *it &lt;&lt; endl;
    <span class="org-keyword">else</span> cout &lt;&lt; <span class="org-string">"not found"</span> &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">reverse</span>
    reverse(v.begin(), v.end());

    <span class="org-keyword">for</span> (<span class="org-type">int</span> &amp;<span class="org-variable-name">i</span>:v) {
        cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span>;
    }
    cout &lt;&lt; endl;

    <span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"abcdef"</span>;
    reverse(s.begin(), s.end());
    cout &lt;&lt; s &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org296876d" class="outline-4">
<h4 id="org296876d"><span class="section-number-4">3.0.4.</span> cpp lambdas</h4>
<div class="outline-text-4" id="text-3-0-4">
<p>
Lambdas in cpp can be used to create functions that are created for one time
use. Lambda funcs can be assigned too.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,3,932,342,4,1};

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : v) {
        cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span>;
    }
    cout &lt;&lt; endl;

    <span class="org-comment-delimiter">// </span><span class="org-comment">sort in descending order using cpp lambdas</span>
    sort(v.begin(), v.end(), [](<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>){ <span class="org-keyword">return</span> a &gt; b; });

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> : v) {
        cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span>;
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; [](<span class="org-type">int</span> <span class="org-variable-name">x</span>){ <span class="org-keyword">return</span> x*2; }(10) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge03fc5f" class="outline-4">
<h4 id="orge03fc5f"><span class="section-number-4">3.0.5.</span> <code>all_of</code>, <code>any_of</code> and, <code>none_of</code></h4>
<div class="outline-text-4" id="text-3-0-5">
<p>
<b><code>all_of</code></b>: returns true if the provided function returns true for all the
 elements.
<b><code>any_of</code></b>: returns true if the provided function returns true for at least one
 element.
<b><code>none_of</code></b>: returns true if the provided function returns false for all the
 elements.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;algorithm&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">v</span> = {1,3,932,342,4,1};

    <span class="org-comment-delimiter">// </span><span class="org-comment">checks if all the elements are greater than 10 (they're not)</span>
    cout &lt;&lt; all_of(v.begin(), v.end(), [](<span class="org-keyword">auto</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a &gt; 10; }) &lt;&lt; endl;
    cout &lt;&lt; any_of(v.begin(), v.end(), [](<span class="org-keyword">auto</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a &gt; 10; }) &lt;&lt; endl;
    <span class="org-comment-delimiter">// </span><span class="org-comment">since none of the elments are negative, it prints 1 (true)</span>
    cout &lt;&lt; none_of(v.begin(), v.end(), [](<span class="org-keyword">auto</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a &lt; 0; }) &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6a8fc58" class="outline-2">
<h2 id="org6a8fc58"><span class="section-number-2">4.</span> Functors</h2>
<div class="outline-text-2" id="text-4">
<p>
TODO look more into this topic (not important for LC)
Classes that act as functions?
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: siddhant</p>
<p class="date">Created: 2022-12-28 Wed 11:20</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
